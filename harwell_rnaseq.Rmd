---
title: "Harwell lab - PRDM16 RNA-Seq"
output:
  html_document:
    theme: cosmo
    toc: true
    toc_depth: 4
    fig_caption: true
    fig_width: 7
    fig_height: 6
author: "Meeta Mistry"
---

```{r setup, echo=FALSE}
 
# Setup report details
clientname="Manuel Baizabal"
clientemail="manuel_baizabal@hms.harvard.edu "
lablocation="Harwell lab" 
analystname="Meeta Mistry"
analystemail="mmistry@hsph.harvard.edu"
```

RNA-Seq analysis for `r clientname` (`r clientemail`) at `r lablocation`. Contact `r analystname` (`r analystemail`) for additional details. Request from client was:     

> Study is to purify cortical stem cells using Pax6 as marker and identify transcriptional changes associated with Pdrm16. Find potential candidate genes to partially rescue the KO phenotype. Experimental setup:
> 
> * 4 x WT Pax+
> * 4 x KO Pax+

## Setup
### Bioconductor and R libraries used

```{r libraries, echo=TRUE}
loadlibs <- function(){
library(ggplot2)
library(reshape)
library(gplots)
library(pheatmap)
library(RColorBrewer)
library(CHBUtils)
library(ggdendro)
library(grid)
library(gridExtra)
library(DESeq2)
library(Biobase)
library(genefilter)
library(CHBUtils)
library(gProfileR)
source('revigo.R') ## for GO analysis
}
suppressPackageStartupMessages(loadlibs())
```

### Set variables
```{r directories, echo=TRUE}
baseDir=getwd()
dataDir=paste(baseDir, "/data", sep="")
resultsDir=paste(baseDir, "/results", sep="")
metaDir=paste(baseDir, "/meta", sep="")

heatcolors.1 <- rev(brewer.pal(6, "YlOrRd"))
heatcolors.2 <- colorRampPalette(brewer.pal(9, "GnBu"))(100)
cbPalette <- cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", 
                            "#D55E00", "#CC79A7", "#000000")

p.cutoff <- 0.05
fc.cutoff <- 1.5
```

### Load data

```{r loadcounts}
data <- read.delim(file.path(dataDir, 'combined.counts'), header=T, sep="\t", row.names=1, as.is=T)
annot <- read.delim(file.path(dataDir, 'annotated_combined.counts'), header=T, sep="\t", row.names=1)

meta <- read.delim(file.path(metaDir, 'project.csv'), header=T, sep=",", row.names=1)

# Change rownames metadata to match counts
rnames <- sapply(rownames(meta), function(x){strsplit(x, split=".", fixed=T)[[1]][1]}, USE.NAMES=F)
row.names(meta) <- rnames

# Re-order meta
meta <- meta[colnames(data),]

# Get unique samples
samples <- sapply(row.names(meta), function(x){strsplit(x, split="_", fixed=T)[[1]][2]}, USE.NAMES=F)
meta$sample <- samples

```

### Aggregate data
Each sample was split in half and run over two lanes for sequencing since we used an entire flow cell. In other words, the libraries GEN00046949_S1_L001, GEN00046949_S1_L002 are the same sample (pool of 2-5 brains in one sort) split across two sequencing lanes.

In the initial QC analysis, we saw that same samples clustered almost identically in the [PCA plot](https://dl.dropboxusercontent.com/u/35207958/harwell_prdm16/qc-summary/qc-summary.html). Before moving forward with any analyses we will first need to aggregate the counts across each sort, by taking the sum accross samples for each individual gene.

```{r}

# Transpose data and add in sample info
tdata <- t(data)
tdata <- data.frame(tdata, samples=samples)

# Aggregate on unique samples
unique_sample_mat <- aggregate(. ~ samples, data=tdata, FUN=sum)

# Transpose back and add in column names
data <- t(unique_sample_mat)
colnames(data) <- data[1,]
data <- data.matrix(data[-1,]) 
class(data) <- "numeric"

# Create a matching metadata file
m <- match(colnames(data), meta$sample)
meta <- meta[m,]
row.names(meta) <- meta$sample

```



## Quality Control

### Sample-to-sample correlation matrix
To visualize clustering of data we will use transformed data by first running the count matrix through [DESeq2](https://www.bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.pdf). For certain comparison analysis using unsupervised techniques, it is useful to transform data. These techniques (i.e. PCA and clustering) perform better when values have a similar dynamic range. Transformation renders data homoskedastic (variance of gene is stabilized across all expression levels), which you don't see with a simple log2 transform. Here, we use the rlog transform which takes into account gene-wise dispersion estimates and size factors (since the coverage varies a bit across samples). 

An intercorrelation heatmap is plotted below generated by taking a correlation of transformed values for all pairwise combinations of samples. The samples show high correlations with each other (values higher than 0.99) indicating no major outliers. **The clustering pattern indicates two major groups associated with WT and KO, and no clear clustering of samples by Sort.** 

```{r cluster-ica, fig.align='center', echo=FALSE, warning=FALSE, message=FALSE}

# Create DESeq2 dataset
dds <- DESeqDataSetFromMatrix(countData = data, colData = meta, design = ~Genotype)
dds <- DESeq(dds)

# Matrix of pseudocounts for downstream visualization: two methods
rld <- rlog(dds, blind = TRUE)

# Heatmap of sample-to-sample correlation matrix
annotation <- data.frame(meta[,c('Genotype', 'Sort')], row.names=row.names(meta))
Genotype <- c("black", "darkgrey")
names(Genotype) <- levels(meta$Genotype)
ann_colors = list(Genotype=Genotype)

pheatmap(cor(assay(rld)), color = heatcolors.1, cluster_rows = T, annotation=annotation, border_color=NA, 
         cluster_cols = T, show_colnames = T, clustering_distance_rows = "euclidean", 
         clustering_distance_cols = "euclidean", 
         fontsize = 10, fontsize_row = 10, height=20)
```


### Hierarchical clustering
```{r dendro, echo=FALSE, fig.align='center', warning=FALSE, message=FALSE}

# Dendrogram
  meta.x <- meta
  transformed_counts <- assay(rld)
  myDist <- dist(t(transformed_counts))
  myTree <-hclust(myDist)
  dhc <- as.dendrogram(myTree)
  ddata <- dendro_data(dhc, type="rectangle")
  ddata$labels <- merge(ddata$labels, meta.x, by.x="label", by.y="row.names")

ggplot(segment(ddata)) +
    geom_segment(aes(x=x, y=y, xend=xend, yend=yend)) +
    theme_dendro() +
    geom_text(data=label(ddata), aes(x=x, y=y, label=label, color= label(ddata)[['Genotype']], 
                                     hjust=-0.1), size=4) +
    coord_flip() + scale_y_reverse(expand=c(0.2, 50)) +
    theme(axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          legend.title=element_blank())

```


### PCA of samples
Using the **500 most variable genes**, we plotted a PCA plot of the first two principal components. The first principal component explains 64.2% of the variance and samples appear to segregate by genotype. This means the difference between WT and KO are evident in this data. For PC2, while a much smaller percentage of variance is explained, we do see that for this component samples separate to some extent based on Sort. Since there is some effect of Sort, it may be a good idea to include it as a covariate in the linear model.


```{r pca, warning=FALSE, fig.align='center', echo=FALSE, fig.width=15}

# Perform PCA (requires transformed data matrix)
ntop <- 500
rv <- rowVars(assay(rld))
select <- order(rv, decreasing=TRUE)[seq_len(ntop)]
pca <- prcomp(t(assay(rld)[select,]))

# Create data frame for input to ggplot
df <- cbind(meta, pca$x[,c('PC1', 'PC2')])

# Plot with sample names used as data points
p1 <- ggplot(df, aes(PC1, PC2, color = Genotype)) + 
  theme_bw() +
  geom_point(size=4) +
  xlab('PC1 (64.2% variance explained)') +
  ylab('PC2 (15.7% variance explained)') +
  scale_x_continuous(expand = c(0.3,  0.3)) +
  theme(plot.title = element_text(size = rel(1.5)),
        axis.title = element_text(size = rel(1.5)),
        axis.text = element_text(size = rel(1.25)))

p2 <- ggplot(df, aes(PC1, PC2, color = Sort)) + 
  theme_bw() +
  geom_point(size=4) +
  xlab('PC1 (64.2% variance explained)') +
  ylab('PC2 (15.7% variance explained)') +
  scale_x_continuous(expand = c(0.3,  0.3)) +
  theme(plot.title = element_text(size = rel(1.5)),
        axis.title = element_text(size = rel(1.5)),
        axis.text = element_text(size = rel(1.25)))

grid.arrange(p1, p2, ncol=2)

```


## Differential Expression 
Starting from count data; we had created a DESeq object. The design formula (~) is used to estimate the dispersions and to estimate the log2 fold changes of the model and p-values based on how significantly genes are changing between WT and KO. A summary of the results are provided below. **At an adjusted p-value < 0.05, there are 418 genes up-regulated and 247 genes down-regulated.** *These expression changes are relative to the WT.*

```{r summary}

# Extract data of specified contrasts
# resultsNames(dds) # uncomment to check names for contrast setup
contrast <- list("GenotypeKO", "GenotypeWT")
res1 <- results(dds, contrast=contrast)
summary(res1, alpha=p.cutoff)

```


### Volcano plots
Taking a look at the distribution of p-values in the volcano plot, we see that the genes identified based on our cutoff are quite significant. Although, for **very few of those genes** do we observe moderately **large fold change** (log2FC > 1.5). Points highlighted in purple **(665 genes)** are those that meet the significance threshold of **adjusted p-value < 0.05**. 

Below we provide links to several files containing results:

* [Full results](./results/WT_vs_KO_full_results.txt) 
* [Up-regulated genes](./results/up-regulated_genes.txt)
* [Down-regulated genes](./results/down-regulated_genes.txt)

```{r volcano plots, fig.align='center', results='asis', echo=FALSE, warning=FALSE, message=FALSE}

# Identify significant genes
res1$threshold <- as.logical(res1$padj < p.cutoff)

# Volcano plots to visualize significant genes
df <- data.frame(res1)
ggplot(data=df, aes(x=log2FoldChange, y=-log10(padj), colour=threshold)) +
  scale_color_manual(values = c("grey", "purple")) +
  xlim(c(-3.5,3.5)) +
  geom_point(alpha=0.75, pch=16) +
  theme(legend.position = "none",
        plot.title = element_text(size = rel(1.5)),
        axis.title = element_text(size = rel(1.5)),
        axis.text = element_text(size = rel(1.25))) +
  xlab("log2 fold change") + ylab("-log10 p-value")

```

```{r write, echo=FALSE, eval=FALSE}
m <- match(rownames(res1), row.names(annot))
geneSymbol <- annot$symbol[m]
out <- cbind(geneSymbol, df)
write.table(out, file="results//WT_vs_KO_full results.txt", sep="\t", quote=F, col.names=NA)

up <- out[which(out$threshold & out$log2FoldChange > 0),]
write.table(up[,c('geneSymbol', 'baseMean', 'log2FoldChange', 'pvalue', 'padj')], 
            file="results/up-regulated_genes.txt", sep="\t", quote=F, col.names=NA)
down <- out[which(out$threshold & out$log2FoldChange < 0),]
write.table(down[,c('geneSymbol', 'baseMean', 'log2FoldChange', 'pvalue', 'padj')], 
            file="results/down-regulated_genes.txt", sep="\t", quote=F, col.names=NA)
```

## Functional Analysis

We separated genes into up- and down-regulated and used each set as input to [gProfileR](http://biit.cs.ut.ee/gprofiler/), a tool that performs statistical enrichment analysis to find over-representation of information like Gene Ontology terms, biological pathways, regulatory DNA elements, human disease gene annotations, and protein-protein interaction networks. From the gprofiler results, the significant terms were extracted and some of the top terms are highlighted in the table below. 

The significant GO terms from gProfiler were also used as input to [REVIGO](http://revigo.irb.hr/) to visualize the most prominent processes and reduce redundancy of terms. Each rectangle is a single cluster representative, where terms sharing parent term at some level have been grouped together. The representatives are joined into ‘superclusters’ of loosely related terms, visualized with different colors. Size of the text reflect either the p-value, or the frequency of the GO term in the underlying GOA database. 

This gives us some biological insight into the genes that are being dysregulated between the two conditions.

### Up-regulated
An Excel spreadsheet containing the full list of gProfiler results for the up-regulated genes can be downloaded [here](./results/gprofiler_upregulated_results.xls).

```{r gprofile-up, results='asis', echo=FALSE}
### Get gene names for only significant genes 
sig <- row.names(res1)[which(res1$threshold & res1$log2FoldChange > 0)]
sig <- unique(sig)

### Functional analysis using gProfiler
gprofiler_results  <-   gprofiler(query = sig, 
                                  organism = "mmusculus",
                                  ordered_query = F, 
                                  exclude_iea = F, 
                                  max_p_value = 0.05, 
                                  max_set_size = 0,
                                  correction_method = "fdr",
                                  hier_filtering = "none", 
                                  domain_size = "annotated",
                                  custom_bg = "")

gprof.table <- gprofiler_results[order(gprofiler_results$p.value), c("term.id", "term.name", "p.value", "term.size", 
                                                                       "overlap.size", "precision","recall")]
gprof.table$p.value <- format(gprof.table$p.value, scientific = T)
kable(head(gprof.table, 10), format='markdown', row.names=F)

```


```{r reviGO-up, echo=FALSE, fig.align='center'}
allterms <- gprofiler_results$term.id
GOs <- allterms[grep('GO:', allterms)]
pvals <- gprofiler_results$p.value[grep('GO:', allterms)]
runRevigo(GOs, pvals)
```


### Down-regulated

An Excel spreadsheet containing the full list of gProfiler results for the down-regulated genes can be downloaded [here](./results/gprofiler_downregulated_results.xls).

```{r gprofile-down, results='asis', echo=FALSE}
### Get gene names for only significant genes 
sig <- row.names(res1)[which(res1$threshold & res1$log2FoldChange < 0)]
sig <- unique(sig)

### Functional analysis using gProfiler
gprofiler_results  <-   gprofiler(query = sig, 
                                  organism = "mmusculus",
                                  ordered_query = F, 
                                  exclude_iea = F, 
                                  max_p_value = 0.05, 
                                  max_set_size = 0,
                                  correction_method = "fdr",
                                  hier_filtering = "none", 
                                  domain_size = "annotated",
                                  custom_bg = "")

gprof.table <- gprofiler_results[order(gprofiler_results$p.value), c("term.id", "term.name", "p.value", "term.size", 
                                                                       "overlap.size", "precision","recall")]
gprof.table$p.value <- format(gprof.table$p.value, scientific = T)
kable(head(gprof.table, 10), format='markdown', row.names=F)
```

```{r reviGO-down, echo=FALSE, fig.align='center'}

allterms <- gprofiler_results$term.id
GOs <- allterms[grep('GO:', allterms)]
pvals <- gprofiler_results$p.value[grep('GO:', allterms)]
runRevigo(GOs, pvals)
```
